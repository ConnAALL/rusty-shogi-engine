/* Russell Kosovsky, Jim O'Conner
 * Module containing the 6 eval functions
    * 1. Piece Square Tables
    * 2. Promoted Pieces
    * 3. King Vulnerability
    * 4. Rook Mobility
    * 5. Lance Mobility
    * 6. Biship Mobility
 */

use crate::sfen;
use std::collections::HashMap;

// ############################################################################################
// ################################## 1. PIECE SQUARE TABLES ##################################
// ############################################################################################

/*
REFERENCE FOR PROMOTED PIECES
    +P / +p ==> Z / z
    
    +L / +l ==> X / x
    
    +N / +n ==> Y / y

    +S / +s ==> Q / q

    +B / +b ==> W / w

    +R / +r ==> E / e
*/


fn pst_parse(sfen: &str) -> Vec<char> {

    let split: Vec<&str> = sfen.split_whitespace().collect();
    let pieces = split[0];
    // println!("{:?}", pieces);
    let replaced = pieces.replace("/", "");
    let clean = sfen::convert_promoted_pieces(&replaced);

    let mut result = Vec::new();
    for ch in clean.chars() {
        if ch.is_digit(10) {
            let count = ch.to_digit(10).unwrap();
            for _ in 0..count {
                result.push('*');
            }
        } else {
            result.push(ch);
        }
    }
    
    result
} 

fn pst() -> HashMap<&'static str, [i32; 81]> {
    let pst: HashMap<&'static str, [i32; 81]> = {
        let mut map = HashMap::new();
        map.insert("P", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("L", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("N", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("S", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("G", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("R", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("B", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("W", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);

        map.insert("E", [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          8, 8, 8, 8, 8, 8, 8, 8, 8,
                          6, 6, 6, 6, 6, 6, 6, 6, 6,
                          4, 4, 4, 4, 4, 4, 4, 4, 4,
                          2, 2, 2, 2, 2, 2, 2, 2, 2,
                          0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0, 0, 0, 0, 0, 0, 0, 0]);
        map
    };
    
    pst // return the hashmap
}


pub fn evaluate_piece_table(sfen: &str) {
    
    let mut white_score = 0;
    let mut black_score = 0;

    let pst_map = pst();
    let sfen_vec = pst_parse(sfen);
    let mut index = 0;
    for i in sfen_vec {
        
        if i == 'p'{
            let value = pst_map["P"][index];
            white_score += value;
        
        } else if i == 'l' {
            let value = pst_map["L"][index];
            white_score += value;

        } else if i == 'n' {
            let value = pst_map["N"][index];
            white_score += value;

        } else if i == 's' {
            let value = pst_map["S"][index];
            white_score += value;

        } else if i == 'g' {
            let value = pst_map["G"][index];
            white_score += value;

        } else if i == 'r' {
            let value = pst_map["R"][index];
            white_score += value;

        } else if i == 'b' {
            let value = pst_map["B"][index];
            white_score += value;

        } else if i == 'e' /* PR rook */ {
            let value = pst_map["E"][index];
            white_score += value;

        } else if i == 'w' /* PR bishop */ {
            let value = pst_map["W"][index];
            white_score += value;

        } else if i == 'z' /* PR pawn */ {
            let value = pst_map["G"][index];
            white_score += value;

        } else if i == 'x' /* PR lance */ {
            let value = pst_map["G"][index];
            white_score += value;

        } else if i == 'y' /* PR knight */ {
            let value = pst_map["G"][index];
            white_score += value;

        } else if i == 'q' /* PR siLver */ {
            let value = pst_map["G"][index];
            white_score += value; 
        }

        // black
        else if i == 'P' {

        } else if i == 'L' {

        } else if i == 'N' {

        } else if i == 'S' {

        } else if i == 'G' {

        } else if i == 'R' {

        } else if i == 'B' {

        } else if i == 'E' {

        } else if i == 'W' {

        } else if i == 'Z' {

        } else if i == 'X' {

        } else if i == 'Y' {

        } else if i == 'Q' {
        
        } else if i == 'k' {

        } else if i == 'K' {
        
        }

        index += 1;
    }

    println!("{:?}", white_score);
}


// ############################################################################################



// ############################################################################################
// #################################### 2. PROMOTED PIECES ####################################
// ############################################################################################

// ############################################################################################



// ###########################################################################################
// ################################## 3. KING VULNERABILITY ##################################
// ###########################################################################################

// ###########################################################################################



// ##########################################################################################
// #################################### 4. ROOK MOBILITY ####################################
// ##########################################################################################

// ##########################################################################################



// ###########################################################################################
// #################################### 5. LANCE MOBILITY ####################################
// ###########################################################################################

// ###########################################################################################



// ############################################################################################
// #################################### 6. BISHOP MOBILITY ####################################
// ############################################################################################

// ############################################################################################




